generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENTIDADES ORGANIZACIONAIS
// ============================================

model Institute {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  hospitals Hospital[]
  users     User[]
  courses   Course[]
  invites   InviteToken[]

  @@map("institutes")
}

model Hospital {
  id          String   @id @default(cuid())
  name        String
  instituteId String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  institute Institute     @relation(fields: [instituteId], references: [id])
  units     Unit[]
  invites   InviteToken[]

  @@map("hospitals")
}

model Unit {
  id         String   @id @default(cuid())
  name       String
  hospitalId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  hospital    Hospital             @relation(fields: [hospitalId], references: [id])
  assignments UserUnitAssignment[]
  invites     InviteToken[]

  @@map("units")
}

// ============================================
// USUÁRIOS E LOTAÇÃO
// ============================================

model User {
  id                   String    @id @default(cuid())
  email                String    @unique
  passwordHash         String?
  name                 String
  cpf                  String    @unique
  phone                String?
  profession           String    // Ex: "Médico", "Enfermeiro", "Fisioterapeuta"
  professionalRegister String?   // CRM, COREN, CREFITO, etc.
  role                 UserRole  @default(USER)
  instituteId          String
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  institute              Institute                  @relation(fields: [instituteId], references: [id])
  unitAssignments        UserUnitAssignment[]
  videoProgress          VideoProgress[]
  quizAttempts           QuizAttempt[]
  competencies           UserCompetency[]
  competencyStates       UserCompetencyState[]
  reviewSchedules        CompetencyReviewSchedule[]
  auditLogs              AuditLog[]
  createdInvites         InviteToken[]
  createdAssignments     Assignment[]               @relation("AssignmentCreator")
  assignmentStatuses     UserAssignmentStatus[]
  certificates           Certificate[]
  createdTickets         Ticket[]                   @relation("TicketCreator")
  assignedTickets        Ticket[]                   @relation("TicketAssignee")
  ticketMessages         TicketMessage[]
  ticketAttachments      TicketAttachment[]
  createdFAQs            FAQ[]
  notifications          Notification[]
  lessonLastSeen         LessonLastSeen[]
  clinicalCases          ClinicalCase[]
  emailPreference        EmailPreference?

  @@map("users")
}

enum UserRole {
  ADMIN_MASTER
  ADMIN
  MANAGER
  USER
}

model UserUnitAssignment {
  id        String    @id @default(cuid())
  userId    String
  unitId    String
  startAt   DateTime  @default(now())
  endAt     DateTime?
  isPrimary Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id])
  unit Unit @relation(fields: [unitId], references: [id])

  @@map("user_unit_assignments")
}

// ============================================
// CONTEÚDO E APRENDIZADO
// ============================================

model Course {
  id                        String        @id @default(cuid())
  title                     String
  description               String?
  instituteId               String
  status                    ContentStatus @default(DRAFT)
  sortOrder                 Int           @default(0)
  currentDraftVersionId     String?       // Versão DRAFT atual
  currentPublishedVersionId String?       // Versão PUBLISHED atual (visível para alunos)
  metadata                  Json?         // Para rastreio de importação: { externalId, importBatchId }
  createdAt                 DateTime      @default(now())
  updatedAt                 DateTime      @updatedAt

  institute    Institute       @relation(fields: [instituteId], references: [id])
  modules      Module[]
  tickets      Ticket[]
  assignments  Assignment[]
  certificates Certificate[]
  faqs         FAQ[]
  versions     CourseVersion[]

  @@map("courses")
}

model CourseVersion {
  id              String              @id @default(cuid())
  instituteId     String
  courseId        String
  versionNumber   Int
  status          CourseVersionStatus @default(DRAFT)
  createdByUserId String
  publishedAt     DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([courseId, versionNumber])
  @@map("course_versions")
}

enum CourseVersionStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model Module {
  id        String        @id @default(cuid())
  title     String
  description String?
  courseId  String
  status    ContentStatus @default(DRAFT)
  sortOrder Int           @default(0)
  metadata  Json?         // Para rastreio de importação: { externalId, importBatchId }
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  course  Course   @relation(fields: [courseId], references: [id])
  lessons Lesson[]

  @@map("modules")
}

model Lesson {
  id                String        @id @default(cuid())
  title             String
  description       String?
  moduleId          String
  youtubeVideoId    String?       // ID do vídeo no YouTube (não listado)
  durationSeconds   Int           @default(0) // Duração do vídeo em segundos
  minWatchPercent   Int           @default(90) // % mínimo para liberar quiz
  practicalSummary  String?       // Resumo prático da aula
  tomorrowChecklist String?       // O que fazer amanhã no plantão
  status            ContentStatus @default(DRAFT)
  sortOrder         Int           @default(0)
  metadata          Json?         // Para rastreio de importação: { externalId, importBatchId }
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  module             Module             @relation(fields: [moduleId], references: [id])
  quiz               Quiz?
  videoProgress      VideoProgress[]
  tickets            Ticket[]
  lessonCompetencies LessonCompetency[]
  lastSeenBy         LessonLastSeen[]

  @@map("lessons")
}

// Registro de última aula acessada
model LessonLastSeen {
  id       String   @id @default(cuid())
  userId   String
  lessonId String
  seenAt   DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  lesson Lesson @relation(fields: [lessonId], references: [id])

  @@unique([userId, lessonId])
  @@map("lesson_last_seen")
}

enum ContentStatus {
  DRAFT
  REVIEWED
  APPROVED
  PUBLISHED
  ARCHIVED
}

model VideoProgress {
  id             String   @id @default(cuid())
  userId         String
  lessonId       String
  watchedSeconds Int      @default(0)
  watchedPct     Int      @default(0) // 0-100
  completed      Boolean  @default(false)
  lastWatchedAt  DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  lesson Lesson @relation(fields: [lessonId], references: [id])

  @@unique([userId, lessonId])
  @@map("video_progress")
}

// ============================================
// QUIZ E AVALIAÇÃO
// ============================================

model Quiz {
  id        String   @id @default(cuid())
  lessonId  String   @unique
  title     String?
  minScore  Int      @default(70) // Nota mínima para aprovação
  metadata  Json?    // Para rastreio de importação: { externalId, importBatchId }
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lesson    Lesson       @relation(fields: [lessonId], references: [id])
  questions Question[]
  attempts  QuizAttempt[]

  @@map("quizzes")
}

model Question {
  id                    String       @id @default(cuid())
  quizId                String?      // Nullable para questões do banco de competência
  text                  String
  type                  QuestionType @default(MULTIPLE_CHOICE)
  justificationRequired Boolean      @default(false) // Exige justificativa? (para CASE)
  sortOrder             Int          @default(0)
  metadata              Json?        // Para rastreio de importação: { externalId, importBatchId }
  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt

  quiz                   Quiz?                    @relation(fields: [quizId], references: [id], onDelete: Cascade)
  options                Option[]
  answers                QuestionAnswer[]
  competencyQuestionBank CompetencyQuestionBank[]

  @@map("questions")
}

enum QuestionType {
  MULTIPLE_CHOICE  // Uma resposta correta
  MULTIPLE_SELECT  // Múltiplas respostas corretas
  CASE             // Caso clínico com justificativa
}

model Option {
  id         String   @id @default(cuid())
  questionId String
  text       String
  isCorrect  Boolean  @default(false)
  sortOrder  Int      @default(0)
  metadata   Json?    // Para rastreio de importação: { externalId, importBatchId }
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("options")
}

model QuizAttempt {
  id            String            @id @default(cuid())
  userId        String
  quizId        String
  lessonId      String            // Referência direta à aula para facilitar queries
  attemptNumber Int               // Tentativa dentro do ciclo (1, 2 ou 3)
  cycleNumber   Int               @default(1) // Ciclo de tentativas
  score         Int?              // Nota obtida (0-100)
  status        QuizAttemptStatus
  startedAt     DateTime          @default(now())
  finishedAt    DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  user    User             @relation(fields: [userId], references: [id])
  quiz    Quiz             @relation(fields: [quizId], references: [id])
  answers QuestionAnswer[]
  tickets Ticket[]

  @@map("quiz_attempts")
}

// Registro de aprovação da aula (após passar no quiz)
model LessonApproval {
  id          String   @id @default(cuid())
  userId      String
  lessonId    String
  quizAttemptId String @unique // Tentativa que aprovou
  score       Int      // Nota obtida
  cycleNumber Int      // Em qual ciclo passou
  passedAt    DateTime @default(now())
  createdAt   DateTime @default(now())

  @@unique([userId, lessonId])
  @@map("lesson_approvals")
}

enum QuizAttemptStatus {
  IN_PROGRESS
  PASSED
  FAILED
  REQUIRES_REWATCH
}

model QuestionAnswer {
  id                String   @id @default(cuid())
  attemptId         String
  questionId        String
  selectedOptionIds Json     @default("[]") // Array de IDs das opções selecionadas
  justificationText String?  // Justificativa para casos clínicos
  isCorrect         Boolean?
  createdAt         DateTime @default(now())

  attempt  QuizAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question    @relation(fields: [questionId], references: [id])

  @@map("question_answers")
}

// ============================================
// COMPETÊNCIAS E REVISÕES
// ============================================

model Competency {
  id          String   @id @default(cuid())
  instituteId String
  name        String
  description String?
  metadata    Json?    // Para rastreio de importação: { externalId, importBatchId }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  lessonCompetencies     LessonCompetency[]
  questionBank           CompetencyQuestionBank[]
  reviewSchedules        CompetencyReviewSchedule[]
  userCompetencyStates   UserCompetencyState[]

  @@map("competencies")
}

// Liga uma aula a competências
model LessonCompetency {
  id           String @id @default(cuid())
  lessonId     String
  competencyId String
  createdAt    DateTime @default(now())

  lesson     Lesson     @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  competency Competency @relation(fields: [competencyId], references: [id], onDelete: Cascade)

  @@unique([lessonId, competencyId])
  @@map("lesson_competencies")
}

// Banco de questões para revisões de competência
model CompetencyQuestionBank {
  id           String   @id @default(cuid())
  competencyId String
  questionId   String
  createdAt    DateTime @default(now())

  competency Competency @relation(fields: [competencyId], references: [id], onDelete: Cascade)
  question   Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([competencyId, questionId])
  @@map("competency_question_bank")
}

// Agendamento de revisões (7, 30, 90 dias)
model CompetencyReviewSchedule {
  id           String               @id @default(cuid())
  userId       String
  competencyId String
  dueAt        DateTime
  status       ReviewScheduleStatus @default(DUE)
  doneAt       DateTime?
  score        Int?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  user       User       @relation(fields: [userId], references: [id])
  competency Competency @relation(fields: [competencyId], references: [id])

  @@map("competency_review_schedules")
}

enum ReviewScheduleStatus {
  DUE
  DONE
  OVERDUE
}

// Estado atual da competência do usuário
model UserCompetencyState {
  id           String          @id @default(cuid())
  userId       String
  competencyId String
  state        CompetencyState @default(GREEN)
  lastReviewAt DateTime?
  nextDueAt    DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  user       User       @relation(fields: [userId], references: [id])
  competency Competency @relation(fields: [competencyId], references: [id])

  @@unique([userId, competencyId])
  @@map("user_competency_states")
}

enum CompetencyState {
  GREEN
  YELLOW
  ORANGE
  RED
}

// DEPRECATED: Manter para compatibilidade, mas usar UserCompetencyState
model UserCompetency {
  id           String          @id @default(cuid())
  userId       String
  competencyId String
  status       CompetencyStatus @default(RED)
  achievedAt   DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  user       User       @relation(fields: [userId], references: [id])

  @@unique([userId, competencyId])
  @@map("user_competencies")
}

enum CompetencyStatus {
  GREEN
  YELLOW
  ORANGE
  RED
}

// ============================================
// SUPORTE E TICKETS
// ============================================

model Ticket {
  id               String         @id @default(cuid())
  instituteId      String
  createdByUserId  String
  assignedToUserId String?
  status           TicketStatus   @default(OPEN)
  category         TicketCategory @default(OTHER)
  priority         TicketPriority @default(MEDIUM)
  subject          String
  courseId         String?
  lessonId         String?
  quizAttemptId    String?
  assignmentId     String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  createdBy   User          @relation("TicketCreator", fields: [createdByUserId], references: [id])
  assignedTo  User?         @relation("TicketAssignee", fields: [assignedToUserId], references: [id])
  course      Course?       @relation(fields: [courseId], references: [id])
  lesson      Lesson?       @relation(fields: [lessonId], references: [id])
  quizAttempt QuizAttempt?  @relation(fields: [quizAttemptId], references: [id])
  messages    TicketMessage[]
  attachments TicketAttachment[]

  @@map("tickets")
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketCategory {
  CONTENT
  QUIZ
  TECHNICAL
  CERTIFICATE
  ASSIGNMENT
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
}

model TicketMessage {
  id           String   @id @default(cuid())
  ticketId     String
  authorUserId String
  message      String
  createdAt    DateTime @default(now())

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorUserId], references: [id])

  @@map("ticket_messages")
}

model TicketAttachment {
  id               String   @id @default(cuid())
  ticketId         String
  uploadedByUserId String
  filename         String
  mimeType         String
  sizeBytes        Int
  storagePath      String
  createdAt        DateTime @default(now())

  ticket     Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  uploadedBy User   @relation(fields: [uploadedByUserId], references: [id])

  @@map("ticket_attachments")
}

// ============================================
// FAQ
// ============================================

model FAQ {
  id              String    @id @default(cuid())
  instituteId     String
  courseId        String
  question        String
  answer          String
  status          FAQStatus @default(DRAFT)
  createdByUserId String
  metadata        Json?     // Para rastreio de importação: { externalId, importBatchId }
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  course    Course @relation(fields: [courseId], references: [id])
  createdBy User   @relation(fields: [createdByUserId], references: [id])

  @@map("faqs")
}

enum FAQStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

// ============================================
// NOTIFICAÇÕES
// ============================================

model Notification {
  id          String           @id @default(cuid())
  instituteId String
  userId      String
  type        NotificationType
  title       String
  body        String
  readAt      DateTime?
  createdAt   DateTime         @default(now())

  user User @relation(fields: [userId], references: [id])

  @@map("notifications")
}

enum NotificationType {
  TICKET_REPLY
  TICKET_STATUS
  ASSIGNMENT_NEW
  CERTIFICATE_ISSUED
  REVIEW_DUE
  COMPETENCY_DEGRADED
}

// ============================================
// CONVITES
// ============================================

model InviteToken {
  id              String    @id @default(cuid())
  token           String    @unique @default(cuid())
  instituteId     String
  hospitalId      String?
  unitId          String?
  systemRole      UserRole  @default(USER)
  profession      String
  invitedEmail    String?
  expiresAt       DateTime
  usedAt          DateTime?
  createdByUserId String
  createdAt       DateTime  @default(now())

  institute Institute @relation(fields: [instituteId], references: [id])
  hospital  Hospital? @relation(fields: [hospitalId], references: [id])
  unit      Unit?     @relation(fields: [unitId], references: [id])
  createdBy User      @relation(fields: [createdByUserId], references: [id])

  @@map("invite_tokens")
}

// ============================================
// ATRIBUIÇÕES E PRAZOS
// ============================================

model Assignment {
  id              String   @id @default(cuid())
  instituteId     String
  courseId        String
  title           String   // Ex: "Treinamento Sepse Janeiro"
  startAt         DateTime
  dueAt           DateTime
  createdByUserId String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  course    Course            @relation(fields: [courseId], references: [id])
  createdBy User              @relation("AssignmentCreator", fields: [createdByUserId], references: [id])
  scopes    AssignmentScope[]
  statuses  UserAssignmentStatus[]

  @@map("assignments")
}

model AssignmentScope {
  id           String               @id @default(cuid())
  assignmentId String
  scopeType    AssignmentScopeType
  profession   String?              // Required quando scopeType envolve profissão
  unitId       String?              // Required quando scopeType envolve unidade
  createdAt    DateTime             @default(now())

  assignment Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)

  @@map("assignment_scopes")
}

enum AssignmentScopeType {
  INSTITUTE_PROFESSION  // Profissão no Instituto inteiro
  UNIT_ALL              // Unidade inteira, multiprofissional
  UNIT_PROFESSION       // Profissão dentro de uma unidade
}

model UserAssignmentStatus {
  id           String                   @id @default(cuid())
  assignmentId String
  userId       String
  status       UserAssignmentStatusEnum @default(PENDING)
  completedAt  DateTime?
  createdAt    DateTime                 @default(now())
  updatedAt    DateTime                 @updatedAt

  assignment Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id])

  @@unique([assignmentId, userId])
  @@map("user_assignment_statuses")
}

enum UserAssignmentStatusEnum {
  PENDING
  IN_PROGRESS
  COMPLETED_ON_TIME
  COMPLETED_LATE
}

// ============================================
// CERTIFICADOS
// ============================================

model Certificate {
  id          String   @id @default(cuid())
  code        String   @unique // Código curto para verificação (ex: ABC123XY)
  instituteId String
  userId      String
  courseId    String
  issuedAt    DateTime @default(now())
  totalHours  Int?     // Carga horária (opcional no MVP)
  pdfPath     String?  // Caminho do PDF no filesystem
  metadata    Json?    // Dados adicionais: nome usuário, nome curso, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  course Course @relation(fields: [courseId], references: [id])
  audits CertificateAudit[]

  @@unique([userId, courseId]) // Um certificado por curso por usuário
  @@map("certificates")
}

model CertificateAudit {
  id            String               @id @default(cuid())
  certificateId String
  event         CertificateAuditEvent
  ipAddress     String?
  userAgent     String?
  createdAt     DateTime             @default(now())

  certificate Certificate @relation(fields: [certificateId], references: [id], onDelete: Cascade)

  @@map("certificate_audits")
}

enum CertificateAuditEvent {
  ISSUED
  DOWNLOADED
  VERIFIED
}

// ============================================
// CASOS CLÍNICOS E LGPD
// ============================================

model ClinicalCase {
  id              String             @id @default(cuid())
  instituteId     String
  title           String
  textAnonymized  String             @db.Text
  status          ClinicalCaseStatus @default(DRAFT)
  createdByUserId String
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  createdBy         User               @relation(fields: [createdByUserId], references: [id])
  anonymizationLogs AnonymizationLog[]

  @@map("clinical_cases")
}

enum ClinicalCaseStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model AnonymizationRule {
  id          String   @id @default(cuid())
  instituteId String
  name        String
  pattern     String   // Regex pattern
  replacement String   // Texto de substituição
  isEnabled   Boolean  @default(true)
  isCritical  Boolean  @default(false) // Se true, bloqueia publicação
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("anonymization_rules")
}

model AnonymizationLog {
  id                String   @id @default(cuid())
  instituteId       String
  clinicalCaseId    String
  actorUserId       String
  appliedRulesCount Int
  findings          Json     // { type: string, count: number }[]
  createdAt         DateTime @default(now())

  clinicalCase ClinicalCase @relation(fields: [clinicalCaseId], references: [id], onDelete: Cascade)

  @@map("anonymization_logs")
}

// ============================================
// AUDITORIA
// ============================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String   // Ex: LOGIN, LESSON_COMPLETED, QUIZ_ATTEMPT, CERTIFICATE_ISSUED
  entity    String?  // Ex: User, Lesson, Quiz
  entityId  String?
  metadata  Json?    // Dados adicionais do evento
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

// ============================================
// E-MAIL E COMUNICAÇÃO
// ============================================

model EmailTemplate {
  id              String   @id @default(cuid())
  key             String   @unique // INVITE_CREATED, ASSIGNMENT_DUE_SOON, etc.
  version         Int      @default(1)
  subject         String
  htmlBody        String   @db.Text
  textBody        String   @db.Text
  variablesSchema Json     // Lista de variáveis esperadas
  isActive        Boolean  @default(true)
  createdByUserId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("email_templates")
}

model EmailOutbox {
  id                String            @id @default(cuid())
  instituteId       String
  eventKey          String            // Tipo do evento
  toEmail           String
  toName            String?
  templateKey       String
  templateVersion   Int
  payload           Json              // Variáveis para renderização
  dedupKey          String            // Chave única para deduplicação
  status            EmailOutboxStatus @default(PENDING)
  scheduledAt       DateTime          @default(now())
  sentAt            DateTime?
  attempts          Int               @default(0)
  lastError         String?           @db.Text
  providerMessageId String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  audits EmailAudit[]

  @@unique([instituteId, dedupKey])
  @@index([status, scheduledAt])
  @@map("email_outbox")
}

enum EmailOutboxStatus {
  PENDING
  SENDING
  SENT
  FAILED
  CANCELLED
  SKIPPED
}

model EmailPreference {
  id               String   @id @default(cuid())
  userId           String   @unique
  emailEnabled     Boolean  @default(true)
  digestEnabled    Boolean  @default(true)
  remindersEnabled Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("email_preferences")
}

model EmailAudit {
  id        String           @id @default(cuid())
  outboxId  String
  action    EmailAuditAction
  meta      Json?
  createdAt DateTime         @default(now())

  outbox EmailOutbox @relation(fields: [outboxId], references: [id], onDelete: Cascade)

  @@map("email_audits")
}

enum EmailAuditAction {
  ENQUEUED
  SENT
  FAILED
  SKIPPED
}
